---
title: "DCRW examples"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DCRW examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: bibliography.bib
csl: apa-old-doi-prefix.csl
# output: 
#   github_document:
#     toc_dept: 1
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

> This page shows how the examples in section 3.1 of @shankar2025 are generated.

```{r setup, message=FALSE}
library(roams)
library(janitor)
library(tsibble)
```

These examples all use the first-differenced correlated random walk (DCRW) model, a type of linear Gaussian SSM. This model is detailed in @auger-methe_guide_2021. The DCRW model has the following observation and state processes,
\begin{align} \label{eq:DCRW_equations}
\begin{split}
    \mathbf{y}_t &= \mathbf{z}_{t} + \mathbf{v}_t \\
    \mathbf{z}_t &= \mathbf{z}_{t-1} + \phi(\mathbf{z}_{t-1} - \mathbf{z}_{t-2}) + \mathbf{w}_t,
\end{split}
\end{align}
where $\mathbf{y}_t$ is the location observed by the satellite, $\mathbf{v}_t$ is the error from the satellite measurements, $\mathbf{z}_t$ is the true location of the whale, and $\mathbf{w}_t$ captures the randomness in the whale's movement. Both $\mathbf{y}_t$ and $\mathbf{z}_t$ are 2-dimensional vectors containing longitude and latitude coordinates. The DCRW model assumes that the whale's location depends on the previous location $\mathbf{z}_{t-1}$, and the previous direction and speed of movement $\mathbf{z}_{t-1} - \mathbf{z}_{t-2}$. The amount of dependence on $\mathbf{z}_{t-1} - \mathbf{z}_{t-2}$ is determined by the correlation parameter $\phi\in [0,1)$.

Notice the use of $\mathbf{z}$ instead of $\mathbf{x}$ for the state process; the DCRW model above is not in state-space form since the state process depends on the previous \textit{two} states, $\mathbf{z}_{t-1}$ and $\mathbf{z}_{t-2}$. This presentation makes it easier to understand the model dynamics, but in order to estimate the parameters of the model, the model must be converted into state-space form.

We use a diagonal structure for the observation error variance matrix, allowing for different variances to be estimated for the longitude and the latitude directions,
\begin{align*}
    \mathbf{\Sigma}_\mathbf{v} &= \left[\begin{matrix}\sigma^2_{\mathbf{v},\text{lon}} & 0 \\ 0 & \sigma^2_{\mathbf{v},\text{lat}} \end{matrix}\right].
\end{align*}
A similar matrix is used for the state error variance matrix $\mathbf{\Sigma}_\mathbf{w}$.
$$
\begin{align}
\left[
\begin{matrix}
\mathbf z_t \\ \mathbf z_{t-1}
\end{matrix}
\right] &= 
\left[
\begin{matrix}
1+\gamma&0&-\gamma&0 \\
0&1+\gamma&0&-\gamma \\
1&0&0&0 \\
0&1&0&0 \\
\end{matrix}
\right]
\left[
\begin{matrix}
\mathbf z_{t-1} \\ \mathbf z_{t-2}
\end{matrix}
\right] + \boldsymbol \epsilon_t, \ \ \boldsymbol \epsilon_t \sim N\left(\mathbf 0, \boldsymbol \Sigma \right), \\
\boldsymbol\Sigma &= \left[
\begin{matrix}
\sigma^2_{\epsilon,lon}&0&0&0 \\
0&\sigma^2_{\epsilon,lat}&0&0 \\
0&0&0&0 \\
0&0&0&0 \\
\end{matrix}
\right] \\
\mathbf y_t &=
\left[
\begin{matrix}
1&0&0&0 \\
0&1&0&0
\end{matrix}
\right]
\left[
\begin{matrix}
\mathbf z_t \\ \mathbf z_{t-1}
\end{matrix}\right] + \boldsymbol \eta_t, \ \ \boldsymbol \eta_t \sim N\left(\mathbf 0, \mathbf R \right), \\
\mathbf R &= \left[
\begin{matrix}
\sigma^2_{\eta,lon}&0 \\
0&\sigma^2_{\eta,lat}  \\
\end{matrix}
\right] \\
\text{initial state} &= (\mathbf y_1, \mathbf y_1) \\
\text{initial state variance} &= \mathbf 0_{4\times 4}
\end{align}
$$


## Blue whale (2008)

```{r whale_2008_import, message=FALSE}
whale_2008 = read_csv("data/Blue whales Eastern North Pacific 1993-2008 - Argos Data.csv") |>
  # Standardise column names
  janitor::clean_names() |>  
  # Keep only rows for the whale with ID "2008CA-Bmu-10839"
  filter(individual_local_identifier == "2008CA-Bmu-10839") |> 
  # Replace missing values in 'manually_marked_outlier' with FALSE
  mutate(manually_marked_outlier = tidyr::replace_na(manually_marked_outlier, FALSE)) |> 
  # Round timestamps to the nearest 12 hours
  mutate(timestamp = lubridate::round_date(timestamp, "12 hours")) |> 
  # Within each group, keep only the last row (e.g. latest observation per 12-hour block)
  group_by(timestamp) |> 
  slice_tail(n = 1) |> 
  # Convert the data to a tsibble object (time series tibble)
  tsibble::tsibble() |>
  # Fill in missing time points in the series with explicit gaps
  tsibble::fill_gaps() |>
   # Convert back to a regular tibble
  as_tibble() |> 
  # Rename longitude/latitude columns to x and y
  rename(x = location_long,
         y = location_lat)
```

Plot with world map data:

```{r}
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)

# Get country boundaries as an sf object
world <- ne_countries(scale = "medium", returnclass = "sf")

# Work out x/y ranges with some padding
x_range <- range(whale_2008$x, na.rm = TRUE)
y_range <- range(whale_2008$y, na.rm = TRUE)

x_pad <- diff(x_range) * 0.05  # 5% padding
y_pad <- diff(y_range) * 0.05 # 5% padding

whale_2008 %>% 
  ggplot() +
  # Country boundaries
  geom_sf(data = world, fill = "grey95", colour = "grey70", size = 0.3) +
  
  # Whale track and points
  geom_path(aes(x = x, y = y, colour = timestamp), alpha = 0.2) +
  geom_point(aes(x = x, y = y, colour = timestamp)) +
  
  # Colour scale
  viridis::scale_color_viridis() +
  
  # Focus map on whaleâ€™s range
  coord_sf(
    xlim = c(x_range[1] - x_pad, x_range[2] + x_pad),
    ylim = c(y_range[1] - y_pad, y_range[2] + y_pad),
    expand = FALSE
  ) +
  
  # Labels and theme
  labs(x = "Longitude", y = "Latitude", subtitle = "whale_2008") +
  theme_minimal() +
  theme(legend.position = "none")
```


## Polar bear


## Seal
